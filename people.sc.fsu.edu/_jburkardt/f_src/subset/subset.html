<html>

  
<!-- Mirrored from people.sc.fsu.edu/~jburkardt/f_src/subset/subset.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 21 Nov 2017 21:20:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
      SUBSET - Combinatorial Routines
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      SUBSET <br> Combinatorial Routines
    </h1>

    <hr>

    <p>
      <b>SUBSET</b>
      is a FORTRAN90 library which
      enumerates, generates, randomizes, ranks and unranks combinatorial objects
      including combinations, compositions, Gray codes, index sets, partitions, 
      permutations, polynomials, subsets, and Young tables.  Backtracking 
      routines are included to solve some combinatorial problems.
    </p>

    <p>
      These include the enumeration, generation, random
      selection, ranking and unranking of
      <ul>
        <li>
          <b>COMP</b>, compositions of an integer N into K parts;
        </li>
        <li>
          <b>COMPNZ</b>, compositions of an integer N into K parts,
          with no zero parts;
        </li>
        <li>
          <b>EQUIV</b>'s, partitions of a set of N objects;
        </li>
        <li>
          <b>I4_PARTITION</b>'s, partitions of an integer;
        </li>
        <li>
          <b>I4POLY</b>'s, integer polynomials in factorial, Newton,
          power sum, or Taylor form;
        </li>
        <li>
          <b>I4VEC</b>'s, integer vectors;
        </li>
        <li>
          <b>KSUB</b>'s, subsets of size K, from a set of N objects;
        </li>
        <li>
          <b>MULTIPERM</b>'s, permutations of the N objects, some of which
          are indistinguishable.
        </li>
        <li>
          <b>PERM</b>'s, permutations of the first N integers;
        </li>
        <li>
          <b>R8POLY</b>'s, real polynomials in factorial, Newton,
          power sum, or Taylor form;
        </li>
        <li>
          <b>KSUB</b>'s, subsets of a set of N objects;
        </li>
        <li>
          vectors whose entries range from 1 to N;
        </li>
        <li>
          <b>YTB</b>'s, Young tables;
        </li>
      </ul>
    </p>

    <p>
      Other objects considered include
      <ul>
        <li>
          the Bell numbers,
        </li>
        <li>
          Catalan numbers,
        </li>
        <li>
          congruence equations.
        </li>
        <li>
          continued fractions,
        </li>
        <li>
          <b>DEC</b>'s, decimal numbers represented as a mantissa and a power of 10;
        </li>
        <li>
          <b>DERANGE</b>'s, derangements (permutations that leave no element in place),
        </li>
        <li>
          <b>DVEC</b>'s, decimal numbers represented as a vector of digits;
        </li>
        <li>
          falling factorials (20*19*18...),
        </li>
        <li>
          <b>GRAY</b>, Gray codes,
        </li>
        <li>
          matrix permanents (similar to determinants, but harder to compute,
          if you can believe that),
        </li>
        <li>
          Morse-Thue numbers,
        </li>
        <li>
          pentagonal numbers,
        </li>
        <li>
          Pythagorean triples,
        </li>
        <li>
          <b>RAT</b>'s, rational numbers represented as a pair of integers;
        </li>
        <li>
          rising factorials (7*8*9...).
        </li>
      </ul>
    </p>

    <p>
      Fortran77 source code for some of the algorithms is
      available in the
      <a href = "http://www.cs.sunysb.edu/~algorith/">
      The Stony Brook Algorithm Archive</a>.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page
      are distributed under
      <a href = "https://people.sc.fsu.edu/~jburkardt/txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>SUBSET</b> is available in
      <a href = "https://people.sc.fsu.edu/~jburkardt/c_src/subset/subset.html">a C version</a> and
      <a href = "https://people.sc.fsu.edu/~jburkardt/cpp_src/subset/subset.html">a C++ version</a> and
      <a href = "https://people.sc.fsu.edu/~jburkardt/f77_src/subset/subset.html">a FORTRAN77 version</a> and
      <a href = "subset.html">a FORTRAN90 version</a> and
      <a href = "https://people.sc.fsu.edu/~jburkardt/m_src/subset/subset.html">a MATLAB version</a> and
      <a href = "https://people.sc.fsu.edu/~jburkardt/py_src/subset/subset.html">a Python version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../backtrack_binary_rc/backtrack_binary_rc.html">
      BACKTRACK_BINARY_RC</a>,
      a FORTRAN90 library which
      carries out a backtrack search for a set of binary decisions, using
      reverse communication.
    </p>

    <p>
      <a href = "../change_making/change_making.html">
      CHANGE_MAKING</a>,
      a FORTRAN90 library which
      considers the change making problem,
      in which a given sum is to be formed using coins of various denominations.
    </p>

    <p>
      <a href = "../combination_lock/combination_lock.html">
      COMBINATION_LOCK</a>,
      a FORTRAN90 program which
      simulates the process of determining the secret combination of a lock.
    </p>

    <p>
      <a href = "../combo/combo.html">
      COMBO</a>,
      a FORTRAN90 library which
      includes many combinatorial routines.
    </p>

    <p>
      <a href = "../floyd/floyd.html">
      FLOYD</a>,
      a FORTRAN90 library which
      implements Floyd's algorithm for finding the shortest distance between pairs of
      nodes on a directed graph.
    </p>

    <p>
      <a href = "../grafpack/grafpack.html">
      GRAFPACK</a>,
      a FORTRAN90 library which
      carries out operations on abstract graphs.
    </p>

    <p>
      <a href = "../knapsack_01/knapsack_01.html">
      KNAPSACK_01</a>,
      a FORTRAN90 library which
      uses brute force to solve small versions of the 0/1 knapsack problem;
    </p>

    <p>
      <a href = "https://people.sc.fsu.edu/~jburkardt/f77_src/lamp/lamp.html">
      LAMP</a>,
      a FORTRAN77 library which
      solves linear assignment and matching problems.
    </p>

    <p>
      <a href = "../legendre_product_polynomial/legendre_product_polynomial.html">
      LEGENDRE_PRODUCT_POLYNOMIAL</a>,
      a FORTRAN90 library which
      defines Legendre product polynomials, creating a multivariate 
      polynomial as the product of univariate Legendre polynomials.
    </p>

    <p>
      <a href = "../monomial/monomial.html">
      MONOMIAL</a>,
      a FORTRAN90 library which
      enumerates, lists, ranks, unranks and randomizes multivariate monomials 
      in a space of M dimensions, with total degree less than N,
      equal to N, or lying within a given range.
    </p>

    <p>
      <a href = "../partial_digest/partial_digest.html">
      PARTIAL_DIGEST</a>,
      a FORTRAN90 library which
      solves the partial digest problem.
    </p>

    <p>
      <a href = "../partition_problem/partition_problem.html">
      PARTITION_PROBLEM</a>,
      a FORTRAN90 library which
      seeks solutions of the partition problem, splitting a set of integers into
      two subsets with equal sum.
    </p>

    <p>
      <a href = "../polynomial/polynomial.html">
      POLYNOMIAL</a>,
      a FORTRAN90 library which
      adds, multiplies, differentiates, evaluates and prints multivariate 
      polynomials in a space of M dimensions.
    </p>

    <p>
      <a href = "../set_theory/set_theory.html">
      SET_THEORY</a>,
      a FORTRAN90 library which
      demonstrates various set theoretic operations using several models of a set.
    </p>

    <p>
      <a href = "../select/select.html">
      SELECT</a>,
      a FORTRAN90 library which
      generates various combinatorial objects.
    </p>

    <p>
      <a href = "../subset_sum/subset_sum.html">
      SUBSET_SUM</a>,
      a FORTRAN90 library which
      seeks solutions of the subset sum problem.
    </p>

    <p>
      <a href = "../toms515/toms515.html">
      TOMS515</a>,
      a FORTRAN90 library which
      can select subsets of size K from a set of size N.
      This is a version of ACM TOMS Algorithm 515,
      by Bill Buckles, Matthew Lybanon.
    </p>

    <p>
      <a href = "../treepack/treepack.html">
      TREEPACK</a>,
      a FORTRAN90 library which
      carries out computations on trees, 
      a simple kind of graph that is minimally connected.
    </p>

    <p>
      <a href = "../unicycle/unicycle.html">
      UNICYCLE</a>,
      a FORTRAN90 library which
      considers permutations containing a single cycle, sometimes called 
      cyclic permutations.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Milton Abramowitz, Irene Stegun,<br>
          Handbook of Mathematical Functions,<br>
          National Bureau of Standards, 1964,<br>
          ISBN: 0-486-61272-4,<br>
          LC: QA47.A34.
        </li>
        <li>
          Walter Ball,<br>
          Mathematical Recreations and Essays,<br>
          Macmillan, 1962,<br>
          ISBN: 1417921269,<br>
          LC: QA95.B2.
        </li>
        <li>
          Paul Bratley, Bennett Fox, Linus Schrage,<br>
          A Guide to Simulation,<br>
          Second Edition,<br>
          Springer, 1987,<br>
          ISBN: 0387964673,<br>
          LC: QA76.9.C65.B73.
        </li>
        <li>
          Bill Buckles, Matthew Lybanon,<br>
          Algorithm 515:
          Generation of a Vector from the Lexicographical Index,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 3, Number 2, June 1977, pages 180-182.
        </li>
        <li>
          Tom Christiansen, Nathan Torkington,<br>
          Perl Cookbook,<br>
          O'Reilly, 2003,<br>
          ISBN: 0596003137,<br>
          LC: QA76.73.P22.C38.
        </li>
        <li>
          William Cody, Kenneth Hillstrom,<br>
          Chebyshev Approximations for the Natural Logarithm of the
          Gamma Function,
          Mathematics of Computation,<br>
          Volume 21, Number 98, April 1967, pages 198-203.
        </li>
        <li>
          John Conway, Richard Guy,<br>
          The Book of Numbers,<br>
          Springer, 1998,<br>
          ISBN: 038797993X,<br>
          LC: QA241.C6897.
        </li>
        <li>
          David Crouse,<br>
          Remark on Algorithm 515,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 33, Number 2, Article 15, June 2007.
        </li>
        <li>
          Bennett Fox,<br>
          Algorithm 647:
          Implementation and Relative Efficiency of Quasirandom
          Sequence Generators,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 12, Number 4, December 1986, pages 362-376.
        </li>
        <li>
          Laurent Habsieger, Maxim Kazarian, Sergei Lando,<br>
          On the Second Number of Plutarch,<br>
          American Mathematical Monthly,<br>
          Volume 105, Number 5, May 1998, page 446.
        </li>
        <li>
          John Halton,<br>
          On the efficiency of certain quasi-random sequences of points
          in evaluating multi-dimensional integrals,<br>
          Numerische Mathematik,<br>
          Volume 2, Number 1, December 1960, pages 84-90.
        </li>
        <li>
          John Hammersley,<br>
          Monte Carlo methods for solving multivariable problems,<br>
          Proceedings of the New York Academy of Science,<br>
          Volume 86, 1960, pages 844-874.
        </li>
        <li>
          John Hart, Ward Cheney, Charles Lawson, Hans Maehly,
          Charles Mesztenyi, John Rice, Henry Thacher,
          Christoph Witzgall,<br>
          Computer Approximations,<br>
          Wiley, 1968,<br>
          LC: QA297.C64.
        </li>
        <li>
          Brian Hayes,<br>
          Third Base,<br>
          American Scientist,<br>
          Volume 89, Number 6, November-December 2001, pages 490-494.
        </li>
        <li>
          Mark Herkommer,<br>
          Number Theory, A Programmer's Guide,<br>
          McGraw Hill, 1999,<br>
          ISBN: 0-07-913074-7.
        </li>
        <li>
          Karla Hoffman, Douglas Shier,<br>
          Algorithm 564:
          A Test Problem Generator for Discrete Linear L1
          Approximation Problems,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 6, Number 4, December 1980, pages 615-617.
        </li>
        <li>
          Donald Knuth,<br>
          The Art of Computer Programming,<br>
          Volume 3, Sorting and Searching,<br>
          Second Edition,<br>
          Addison Wesley, 1998,<br>
          ISBN: 0201896850,<br>
          LC: QA76.6.K64.
        </li>
        <li>
          Hang Tong Lau,<br>
          Algorithms on Graphs,<br>
          Tab Books, 1989,<br>
          ISBN: 0830634290,<br>
          LC: QA166.L38
        </li>
        <li>
          Pierre LEcuyer,<br>
          Random Number Generation,<br>
          in Handbook of Simulation,<br>
          edited by Jerry Banks,<br>
          Wiley, 1998,<br>
          ISBN: 0471134031,<br>
          LC: T57.62.H37.
        </li>
        <li>
          Peter Lewis, Allen Goodman, James Miller,<br>
          A Pseudo-Random Number Generator for the System/360,<br>
          IBM Systems Journal,<br>
          Volume 8, 1969, pages 136-143.
        </li>
        <li>
          Charles Mifsud,<br>
          Algorithm 154,
          Combination in Lexicographic Order,<br>
          Communications of the ACM,<br>
          Volume 6, Number 3, March 1963, page 103.
        </li>
        <li>
          mil_std_1753,<br>
          Military Standard 1753,<br>
          FORTRAN, DoD Supplement To American National Standard X3.9-1978,<br>
          9 November 1978.
        </li>
        <li>
          Albert Nijenhuis, Herbert Wilf,<br>
          Combinatorial Algorithms for Computers and Calculators,<br>
          Second Edition,<br>
          Academic Press, 1978,<br>
          ISBN: 0-12-519260-6,<br>
          LC: QA164.N54.
        </li>
        <li>
          Robert Owens,<br>
          Sums of Powers of Integers,<br>
          Mathematics Magazine,<br>
          Volume 65, Number 1, February 1992, pages 38-40.
        </li>
        <li>
          Norman Richert,<br>
          Strang's Strange Figures,<br>
          American Mathematical Monthly,<br>
          Volume 99, Number 2, February 1992, pages 101-107.
        </li>
        <li>
          James Sandeson,<br>
          Testing Ecological Patterns,<br>
          American Scientist,<br>
          Volume 88, Number 4, July-August 2000, pages 332-339.
        </li>
        <li>
          Ian Saunders,<br>
          Algorithm AS 205,<br>
          Enumeration of R x C Tables with Repeated Row Totals,<br>
          Applied Statistics,<br>
          Volume 33, Number 3, 1984, pages 340-352.
        </li>
        <li>
          Robert Sedgewick,<br>
          Algorithms in C,<br>
          Addison-Wesley, 1990,<br>
          ISBN: 0-201-51425-7,<br>
          LC: QA76.73.C15S43.
        </li>
        <li>
          Raymond Seroul,<br>
          Programming for Mathematicians,<br>
          Springer, 2000,<br>
          ISBN: 3-540-66422-X,<br>
          LC: QA76.6.S465.
        </li>
        <li>
          Mok-Kong Shen,<br>
          Algorithm 202:
          Generation of Permutations in Lexicographical Order,<br>
          Communications of the ACM,<br>
          Volume 6, Number 9, September 1963, page 517.
        </li>
        <li>
          Richard Stanley,<br>
          Hipparchus, Plutarch, Schroeder, and Hough,<br>
          American Mathematical Monthly,<br>
          Volume 104, Number 4, April 1997, pages 344-350.
        </li>
        <li>
          Dennis Stanton, Dennis White,<br>
          Constructive Combinatorics,<br>
          Springer, 1986,<br>
          ISBN: 0387963472,<br>
          LC: QA164.S79.
        </li>
        <li>
          Ian Stewart,<br>
          A Neglected Number,<br>
          Scientific American, <br>
          Volume 274, pages 102-102, June 1996.
        </li>
        <li>
          Ian Stewart,<br>
          Math Hysteria,<br>
          Oxford, 2004,<br>
          ISBN: 0198613369,<br>
          LC: QA95.S7255.
        </li>
        <li>
          James Sylvester,<br>
          Question 7382,
          Mathematical Questions with their Solutions,<br>
          Educational Times,<br>
          Volume 41, page 21, 1884.
        </li>
        <li>
          Hale Trotter,<br>
          Algorithm 115:
          PERM,<br>
          Communications of the Association for Computing Machinery,<br>
          Volume 5, Number 8, August 1962, pages 434-435.
        </li>
        <li>
          Johannes vanderCorput,<br>
          Verteilungsfunktionen I & II,<br>
          Proceedings of the Koninklijke Nederlandsche Akademie
          van Wetenschappen,<br>
          Volume 38, 1935, pages 813-820, pages 1058-1066.
        </li>
        <li>
          Jack vanLint, Richard Wilson,<br>
          A Course in Combinatorics,<br>
          Cambridge, 1992,<br>
          ISBN: 0-521-42260-4,<br>
          LC: QA164.L56.
        </li>
        <li>
          Eric Weisstein,<br>
          CRC Concise Encyclopedia of Mathematics,<br>
          CRC Press, 2002,<br>
          Second edition,<br>
          ISBN: 1584883472,<br>
          LC: QA5.W45
        </li>
        <li>
          Stephen Wolfram,<br>
          The Mathematica Book,<br>
          Fourth Edition,<br>
          Cambridge University Press, 1999,<br>
          ISBN: 0-521-64314-7,<br>
          LC: QA76.95.W65.
        </li>
        <li>
          ML Wolfson, HV Wright,<br>
          ACM Algorithm 160:
          Combinatorial of M Things Taken N at a Time,<br>
          Communications of the ACM,<br>
          Volume 6, Number 4, April 1963, page 161.
        </li>
        <li>
          Daniel Zwillinger, editor,<br>
          CRC Standard Mathematical Tables and Formulae,<br>
          30th Edition,<br>
          CRC Press, 1996,<br>
          ISBN: 0-8493-2479-3,<br>
          LC: QA47.M315.
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "subset.f90">subset.f90</a>, the source code;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "subset_prb.f90">subset_prb.f90</a>, the calling program;
        </li>
        <li>
          <a href = "subset_prb_output.txt">subset_prb_output.txt</a>,
          the output file.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <ul>
        <li>
          <b>ASM_ENUM</b> returns the number of alternating sign matrices of a given order.
        </li>
        <li>
          <b>ASM_TRIANGLE</b> returns a row of the alternating sign matrix triangle.
        </li>
        <li>
          <b>BELL</b> returns the Bell numbers from 0 to N.
        </li>
        <li>
          <b>BELL_VALUES</b> returns some values of the Bell numbers for testing.
        </li>
        <li>
          <b>CATALAN</b> computes the Catalan numbers, from C(0) to C(N).
        </li>
        <li>
          <b>CATALAN_ROW_NEXT</b> computes row N of Catalan's triangle.
        </li>
        <li>
          <b>CATALAN_VALUES</b> returns some values of the Catalan numbers for testing.
        </li>
        <li>
          <b>CFRAC_TO_RAT</b> converts a monic continued fraction to an ordinary fraction.
        </li>
        <li>
          <b>CFRAC_TO_RFRAC</b> converts polynomial fractions from continued to rational form.
        </li>
        <li>
          <b>CH_CAP</b> capitalizes a single character.
        </li>
        <li>
          <b>CHANGE_GREEDY</b> makes change for a given total using the biggest coins first.
        </li>
        <li>
          <b>CHANGE_NEXT</b> computes the next set of change for a given sum.
        </li>
        <li>
          <b>CHINESE_CHECK</b> checks the Chinese remainder moduluses.
        </li>
        <li>
          <b>CHINESE_TO_I4</b> converts a set of Chinese remainders to an equivalent integer.
        </li>
        <li>
          <b>COMB_NEXT</b> computes combinations of K things out of N.
        </li>
        <li>
          <b>COMB_ROW_NEXT</b> computes the next row of Pascal's triangle.
        </li>
        <li>
          <b>COMB_UNRANK</b> returns the RANK-th combination of N things out of M.
        </li>
        <li>
          <b>COMP_ENUM</b> returns the number of compositions of the integer N into K parts.
        </li>
        <li>
          <b>COMP_NEXT</b> computes the compositions of the integer N into K parts.
        </li>
        <li>
          <b>COMP_NEXT_GRLEX</b> returns the next composition in grlex order.
        </li>
        <li>
          <b>COMP_RANDOM</b> selects a random composition of the integer N into K parts.
        </li>
        <li>
          <b>COMP_RANDOM_GRLEX:</b> random composition with degree less than or equal to NC.
        </li>
        <li>
          <b>COMP_RANK_GRLEX</b> computes the graded lexicographic rank of a composition.
        </li>
        <li>
          <b>COMP_TO_KSUB</b> converts a composition to a K-subset.
        </li>
        <li>
          <b>COMP_UNRANK_GRLEX</b> computes the composition of given grlex rank.
        </li>
        <li>
          <b>COMPNZ_ENUM</b> returns the number of nonzero compositions of the N into K parts.
        </li>
        <li>
          <b>COMPNZ_NEXT</b> computes the compositions of the integer N into K nonzero parts.
        </li>
        <li>
          <b>COMPNZ_RANDOM</b> selects a random composition of N into K nonzero parts.
        </li>
        <li>
          <b>COMPNZ_TO_KSUB</b> converts a nonzero composition to a K-subset.
        </li>
        <li>
          <b>CONGRUENCE</b> solves a congruence of the form A * X = C ( mod B ).
        </li>
        <li>
          <b>COUNT_POSE_RANDOM</b> poses a problem for the game "The Count is Good"
        </li>
        <li>
          <b>DEBRUIJN</b> constructs a de Bruijn sequence.
        </li>
        <li>
          <b>DEC_ADD</b> adds two decimal quantities.
        </li>
        <li>
          <b>DEC_DIV</b> divides two decimal values.
        </li>
        <li>
          <b>DEC_MUL</b> multiplies two decimals.
        </li>
        <li>
          <b>DEC_ROUND</b> rounds a decimal fraction to a given number of digits.
        </li>
        <li>
          <b>DEC_TO_R8</b> converts a decimal to an R8.
        </li>
        <li>
          <b>DEC_TO_RAT</b> converts a decimal to a rational representation.
        </li>
        <li>
          <b>DEC_TO_S</b> returns a string representation of a decimal.
        </li>
        <li>
          <b>DEC_WIDTH</b> returns the "width" of a decimal number.
        </li>
        <li>
          <b>DECMAT_DET</b> finds the determinant of an N by N matrix of decimal entries.
        </li>
        <li>
          <b>DECMAT_PRINT</b> prints out decimal vectors and matrices.
        </li>
        <li>
          <b>DERANGE_BACK_CANDIDATE</b> finds values for the K-th entry of a derangement.
        </li>
        <li>
          <b>DERANGE_BACK_NEXT</b> returns the next derangement of N items.
        </li>
        <li>
          <b>DERANGE_CHECK</b> determines whether a permutation is a derangement.
        </li>
        <li>
          <b>DERANGE_ENUM</b> returns the number of derangements of N objects.
        </li>
        <li>
          <b>DERANGE_ENUM2</b> returns the number of derangements of 0 through N objects.
        </li>
        <li>
          <b>DERANGE_ENUM3</b> returns the number of derangements of 0 through N objects.
        </li>
        <li>
          <b>DERANGE_WEED_NEXT</b> computes all derangements of N objects, one at a time.
        </li>
        <li>
          <b>DIGIT_TO_CH</b> returns the character representation of a decimal digit.
        </li>
        <li>
          <b>DIGRAPH_ARC_EULER</b> returns an Euler circuit in a digraph.
        </li>
        <li>
          <b>DIGRAPH_ARC_PRINT</b> prints out a digraph from an edge list.
        </li>
        <li>
          <b>DIOPHANTINE</b> solves a Diophantine equation A * X + B * Y = C.
        </li>
        <li>
          <b>DIOPHANTINE_SOLUTION_MINIMIZE:</b> minimal solution of a Diophantine equation.
        </li>
        <li>
          <b>DVEC_ADD</b> adds two (signed) DVEC's.
        </li>
        <li>
          <b>DVEC_COMPLEMENTX</b> computes the ten's complement of a DVEC.
        </li>
        <li>
          <b>DVEC_MUL</b> computes the product of two DVEC's.
        </li>
        <li>
          <b>DVEC_PRINT</b> prints a DVEC, with an optional title.
        </li>
        <li>
          <b>DVEC_SUB</b> subtracts two DVEC's.
        </li>
        <li>
          <b>DVEC_TO_I4</b> makes an integer from a (signed) DVEC.
        </li>
        <li>
          <b>EQUIV_NEXT</b> computes the partitions of a set one at a time.
        </li>
        <li>
          <b>EQUIV_NEXT2</b> computes, one at a time, the partitions of a set.
        </li>
        <li>
          <b>EQUIV_PRINT</b> prints a partition of a set.
        </li>
        <li>
          <b>EQUIV_PRINT2</b> prints a partition of a set.
        </li>
        <li>
          <b>EQUIV_RANDOM</b> selects a random partition of a set.
        </li>
        <li>
          <b>EULER</b> returns the N-th row of Euler's triangle.
        </li>
        <li>
          <b>FROBENIUS_NUMBER_ORDER2</b> returns the Frobenius number for order 2.
        </li>
        <li>
          <b>FROBENIUS_NUMBER_ORDER2_VALUES:</b> values of the order 2 Frobenius number.
        </li>
        <li>
          <b>GAMMA_LOG_VALUES</b> returns some values of the Log Gamma function.
        </li>
        <li>
          <b>GET_SEED</b> returns a seed for the random number generator.
        </li>
        <li>
          <b>GRAY_NEXT</b> generates the next Gray code by switching one item at a time.
        </li>
        <li>
          <b>GRAY_RANK</b> ranks a Gray code.
        </li>
        <li>
          <b>GRAY_RANK2</b> ranks a Gray code.
        </li>
        <li>
          <b>GRAY_UNRANK</b> unranks a Gray code.
        </li>
        <li>
          <b>GRAY_UNRANK2</b> unranks a Gray code.
        </li>
        <li>
          <b>I4_BCLR</b> returns a copy of an I4 in which the POS-th bit is set to 0.
        </li>
        <li>
          <b>I4_BSET</b> returns a copy of an I4 in which the POS-th bit is set to 1.
        </li>
        <li>
          <b>I4_BTEST</b> returns TRUE if the POS-th bit of an I4 is 1.
        </li>
        <li>
          <b>I4_CHOOSE</b> computes the binomial coefficient C(N,K) as an I4.
        </li>
        <li>
          <b>I4_FACTOR</b> factors an I4 into prime factors.
        </li>
        <li>
          <b>I4_FACTORIAL</b> computes the factorial of N.
        </li>
        <li>
          <b>I4_FALL</b> computes the falling factorial function [X]_N.
        </li>
        <li>
          <b>I4_FALL_VALUES</b> returns values of the integer falling factorial function.
        </li>
        <li>
          <b>I4_GCD</b> finds the greatest common divisor of two I4's.
        </li>
        <li>
          <b>I4_HUGE</b> returns a "huge" I4.
        </li>
        <li>
          <b>I4_LOG_10</b> returns the integer part of the logarithm base 10 of an I4.
        </li>
        <li>
          <b>I4_MODP</b> returns the nonnegative remainder of I4 division.
        </li>
        <li>
          <b>I4_MOEBIUS</b> returns the value of MU(N), the Moebius function of N.
        </li>
        <li>
          <b>I4_PARTITION_CONJ</b> computes the conjugate of a partition.
        </li>
        <li>
          <b>I4_PARTITION_COUNT</b> computes the number of partitions of an I4.
        </li>
        <li>
          <b>I4_PARTITION_COUNT_VALUES</b> returns some values of the integer partition count.
        </li>
        <li>
          <b>I4_PARTITION_COUNT2</b> computes the number of partitions of an I4.
        </li>
        <li>
          <b>I4_PARTITION_NEXT</b> generates the partitions of an I4, one at a time.
        </li>
        <li>
          <b>I4_PARTITION_NEXT2</b> computes the partitions of the integer N one at a time.
        </li>
        <li>
          <b>I4_PARTITION_PRINT</b> prints a partition of an I4.
        </li>
        <li>
          <b>I4_PARTITION_RANDOM</b> selects a random partition of the integer N.
        </li>
        <li>
          <b>I4_PARTITIONS_NEXT:</b> next partition into S parts.
        </li>
        <li>
          <b>I4_RISE</b> computes the rising factorial function [X]^N.
        </li>
        <li>
          <b>I4_RISE_VALUES</b> returns values of the integer rising factorial function.
        </li>
        <li>
          <b>I4_SQRT</b> finds the integer square root of N by solving N = Q*Q + R.
        </li>
        <li>
          <b>I4_SQRT_CF:</b> continued fraction representation of a square root of an integer.
        </li>
        <li>
          <b>I4_SWAP</b> switches two I4's.
        </li>
        <li>
          <b>I4_TO_CHINESE</b> converts an I4 to its Chinese remainder form.
        </li>
        <li>
          <b>I4_TO_DVEC</b> makes a signed DVEC from an I4.
        </li>
        <li>
          <b>I4_TO_I4POLY</b> converts an I4 to an I4POLY in a given base.
        </li>
        <li>
          <b>I4_TO_S_LEFT</b> converts an I4 to a left-justified string.
        </li>
        <li>
          <b>I4_TO_VAN_DER_CORPUT</b> computes an element of a van der Corput sequence.
        </li>
        <li>
          <b>I4_UNIFORM_AB</b> returns a scaled pseudorandom I4 between A and B.
        </li>
        <li>
          <b>I4MAT_01_ROWCOLSUM</b> creates a 0/1 I4MAT with given row and column sums.
        </li>
        <li>
          <b>I4MAT_01_ROWCOLSUM2</b> creates a 0/1 I4MAT with given row and column sums.
        </li>
        <li>
          <b>I4MAT_PERM</b> permutes the rows and columns of a square I4MAT.
        </li>
        <li>
          <b>I4MAT_PERM2</b> permutes the rows and columns of a rectangular I4MAT.
        </li>
        <li>
          <b>I4MAT_PRINT</b> prints an I4MAT.
        </li>
        <li>
          <b>I4MAT_PRINT_SOME</b> prints some of an I4MAT.
        </li>
        <li>
          <b>I4MAT_U1_INVERSE</b> inverts a unit upper triangular I4MAT.
        </li>
        <li>
          <b>I4POLY</b> performs operations on I4POLY's in power or factorial form.
        </li>
        <li>
          <b>I4POLY_ADD</b> adds two I4POLY's.
        </li>
        <li>
          <b>I4POLY_CYCLO</b> computes a cyclotomic polynomial.
        </li>
        <li>
          <b>I4POLY_DEGREE</b> returns the degree of an I4POLY.
        </li>
        <li>
          <b>I4POLY_DIF</b> differentiates an I4POLY.
        </li>
        <li>
          <b>I4POLY_DIV</b> computes the quotient and remainder of two I4POLY's.
        </li>
        <li>
          <b>I4POLY_MUL</b> computes the product of two I4POLY's.
        </li>
        <li>
          <b>I4POLY_PRINT</b> prints an I4POLY.
        </li>
        <li>
          <b>I4POLY_TO_I4</b> evaluates an I4POLY.
        </li>
        <li>
          <b>I4VEC_ASCENDS</b> determines if an I4VEC is (weakly) ascending.
        </li>
        <li>
          <b>I4VEC_BACKTRACK</b> supervises a backtrack search for an I4VEC.
        </li>
        <li>
          <b>I4VEC_DESCENDS</b> determines if an I4VEC is decreasing.
        </li>
        <li>
          <b>I4VEC_FRAC</b> searches for the K-th smallest element in an I4VEC.
        </li>
        <li>
          <b>I4VEC_HEAP_D</b> reorders an I4VEC into an descending heap.
        </li>
        <li>
          <b>I4VEC_INDICATOR</b> sets an I4VEC to the indicator vector.
        </li>
        <li>
          <b>I4VEC_INDEX</b> returns the location of the first occurrence of a given value.
        </li>
        <li>
          <b>I4VEC_MAXLOC_LAST</b> returns the index of the last maximal I4VEC entry.
        </li>
        <li>
          <b>I4VEC_PAIRWISE_PRIME</b> checks whether an I4VEC is pairwise prime.
        </li>
        <li>
          <b>I4VEC_PRINT</b> prints an I4VEC, with an optional title.
        </li>
        <li>
          <b>I4VEC_PRINT_SOME</b> prints "some" of an I4VEC.
        </li>
        <li>
          <b>I4VEC_REVERSE</b> reverses the elements of an I4VEC.
        </li>
        <li>
          <b>I4VEC_SORT_BUBBLE_A</b> ascending sorts an I4VEC using bubble sort.
        </li>
        <li>
          <b>I4VEC_SORT_HEAP_A</b> ascending sorts an I4VEC using heap sort.
        </li>
        <li>
          <b>I4VEC_SORT_HEAP_INDEX_D</b> does an indexed heap descending sort of an I4VEC.
        </li>
        <li>
          <b>I4VEC_SUM</b> returns the sum of the entries of an I4VEC.
        </li>
        <li>
          <b>I4VEC_TRANSPOSE_PRINT</b> prints an I4VEC "transposed".
        </li>
        <li>
          <b>I4VEC_UNIFORM_AB</b> returns a scaled pseudorandom I4VEC.
        </li>
        <li>
          <b>INDEX_BOX2_NEXT_2D</b> produces index vectors on the surface of a box in 2D.
        </li>
        <li>
          <b>INDEX_BOX2_NEXT_3D</b> produces index vectors on the surface of a box in 3D.
        </li>
        <li>
          <b>INDEX_BOX_NEXT_2D</b> produces index vectors on the surface of a box in 2D.
        </li>
        <li>
          <b>INDEX_BOX_NEXT_3D</b> produces index vectors on the surface of a box in 3D.
        </li>
        <li>
          <b>INDEX_NEXT0</b> generates all index vectors within given upper limits.
        </li>
        <li>
          <b>INDEX_NEXT1</b> generates all index vectors within given upper limits.
        </li>
        <li>
          <b>INDEX_NEXT2</b> generates all index vectors within given lower and upper limits.
        </li>
        <li>
          <b>INDEX_RANK0</b> ranks an index vector within given upper limits.
        </li>
        <li>
          <b>INDEX_RANK1</b> ranks an index vector within given upper limits.
        </li>
        <li>
          <b>INDEX_RANK2</b> ranks an index vector within given lower and upper limits.
        </li>
        <li>
          <b>INDEX_UNRANK0</b> unranks an index vector within given upper limits.
        </li>
        <li>
          <b>INDEX_UNRANK1</b> unranks an index vector within given upper limits.
        </li>
        <li>
          <b>INDEX_UNRANK2</b> unranks an index vector within given lower and upper limits.
        </li>
        <li>
          <b>INS_PERM</b> computes a permutation from its inversion sequence.
        </li>
        <li>
          <b>INVERSE_MOD_N</b> computes the inverse of B mod N.
        </li>
        <li>
          <b>INVOLUTE_ENUM</b> enumerates the involutions of N objects.
        </li>
        <li>
          <b>JFRAC_TO_RFRAC</b> converts a J-fraction into a rational polynomial fraction.
        </li>
        <li>
          <b>JOSEPHUS</b> returns the position X of the K-th man to be executed.
        </li>
        <li>
          <b>KSUB_NEXT</b> generates the subsets of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_NEXT2</b> generates the subsets of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_NEXT3</b> generates the subsets of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_NEXT4</b> generates the subsets of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANDOM</b> selects a random subset of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANDOM2</b> selects a random subset of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANDOM3</b> selects a random subset of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANDOM4</b> selects a random subset of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANDOM5</b> selects a random subset of size K from a set of size N.
        </li>
        <li>
          <b>KSUB_RANK</b> computes the rank of a K subset of an N set.
        </li>
        <li>
          <b>KSUB_TO_COMP</b> converts a K-subset to a composition.
        </li>
        <li>
          <b>KSUB_TO_COMPNZ</b> converts a K-subset to a nonzero composition.
        </li>
        <li>
          <b>KSUB_UNRANK</b> returns the subset of a given rank.
        </li>
        <li>
          <b>L4VEC_NEXT</b> generates the next logical vector.
        </li>
        <li>
          <b>MATRIX_PRODUCT_OPT</b> determines the optimal cost of a matrix product.
        </li>
        <li>
          <b>MOEBIUS_MATRIX</b> finds the Moebius matrix from a covering relation.
        </li>
        <li>
          <b>MONOMIAL_COUNT</b> counts the number of monomials up to a given degree.
        </li>
        <li>
          <b>MONOMIAL_COUNTS</b> counts the number of monomials up to a given degree.
        </li>
        <li>
          <b>MORSE_THUE</b> generates a Morse_Thue number.
        </li>
        <li>
          <b>MULTINOMIAL_COEF1</b> computes a multinomial coefficient.
        </li>
        <li>
          <b>MULTINOMIAL_COEF2</b> computes a multinomial coefficient.
        </li>
        <li>
          <b>MULTIPERM_ENUM</b> enumerates multipermutations.
        </li>
        <li>
          <b>MULTIPERM_NEXT</b> returns the next multipermutation.
        </li>
        <li>
          <b>NETWORK_FLOW_MAX</b> finds the maximal flow and a minimal cut in a network.
        </li>
        <li>
          <b>NIM_SUM</b> computes the Nim sum of two integers.
        </li>
        <li>
          <b>PADOVAN</b> returns the first N values of the Padovan sequence.
        </li>
        <li>
          <b>PELL_BASIC</b> returns the fundamental solution for Pell's basic equation.
        </li>
        <li>
          <b>PELL_NEXT</b> returns the next solution of Pell's equation.
        </li>
        <li>
          <b>PENT_ENUM</b> computes the N-th pentagonal number.
        </li>
        <li>
          <b>PERM_ASCEND</b> computes the longest ascending subsequence of a permutation.
        </li>
        <li>
          <b>PERM_BREAK_COUNT</b> counts the number of "breaks" in a permutation.
        </li>
        <li>
          <b>PERM_CANON_TO_CYCLE</b> converts a permutation from canonical to cycle form.
        </li>
        <li>
          <b>PERM_CHECK0</b> checks a 0-based permutation.
        </li>
        <li>
          <b>PERM_CHECK1</b> checks a 1-based permutation.
        </li>
        <li>
          <b>PERM_CYCLE</b> analyzes a permutation.
        </li>
        <li>
          <b>PERM_CYCLE_TO_CANON</b> converts a permutation from cycle to canonical form.
        </li>
        <li>
          <b>PERM_CYCLE_TO_INDEX</b> converts a permutation from cycle to standard index form.
        </li>
        <li>
          <b>PERM_DISTANCE</b> computes the Ulam metric distance of two permutations.
        </li>
        <li>
          <b>PERM_FIXED_ENUM</b> enumerates the permutations of N objects with M fixed.
        </li>
        <li>
          <b>PERM_FREE</b> reports the unused items in a partial permutation.
        </li>
        <li>
          <b>PERM_INDEX_TO_CYCLE</b> converts a permutation from standard index to cycle form.
        </li>
        <li>
          <b>PERM_INS</b> computes the inversion sequence of a permutation.
        </li>
        <li>
          <b>PERM_INVERSE</b> inverts a permutation "in place".
        </li>
        <li>
          <b>PERM_INVERSE2</b> inverts a permutation "in place".
        </li>
        <li>
          <b>PERM_INVERSE3</b> produces the inverse of a given permutation.
        </li>
        <li>
          <b>PERM_LEX_NEXT</b> generates permutations in lexical order, one at a time.
        </li>
        <li>
          <b>PERM_MUL</b> "multiplies" two permutations.
        </li>
        <li>
          <b>PERM_NEXT</b> computes all of the permutations of N objects, one at a time.
        </li>
        <li>
          <b>PERM_NEXT2</b> generates all the permutations of N objects.
        </li>
        <li>
          <b>PERM_NEXT3</b> computes all of the permutations of N objects, one at a time.
        </li>
        <li>
          <b>PERM_PRINT</b> prints a permutation.
        </li>
        <li>
          <b>PERM_RANDOM</b> selects a random permutation of N objects.
        </li>
        <li>
          <b>PERM_RANDOM2</b> selects a random permutation of N objects.
        </li>
        <li>
          <b>PERM_RANDOM3</b> selects a random permutation of N elements.
        </li>
        <li>
          <b>PERM_RANK</b> computes the rank of a given permutation.
        </li>
        <li>
          <b>PERM_SIGN</b> returns the sign of a permutation.
        </li>
        <li>
          <b>PERM_TO_EQUIV</b> computes the partition induced by a permutation.
        </li>
        <li>
          <b>PERM_TO_YTB</b> converts a permutation to a Young table.
        </li>
        <li>
          <b>PERM_UNRANK</b> "unranks" a permutation.
        </li>
        <li>
          <b>PERRIN</b> returns the first N values of the Perrin sequence.
        </li>
        <li>
          <b>PORD_CHECK</b> checks a matrix representing a partial ordering.
        </li>
        <li>
          <b>POWER_MOD</b> computes mod ( A^N, M ).
        </li>
        <li>
          <b>POWER_SERIES1</b> computes the power series for G(Z) = (1+F(Z))^ALPHA.
        </li>
        <li>
          <b>POWER_SERIES2</b> computes the power series for G(Z) = exp(F(Z)) - 1.
        </li>
        <li>
          <b>POWER_SERIES3</b> computes the power series for H(Z) = G(F(Z)).
        </li>
        <li>
          <b>POWER_SERIES4</b> computes the power series for H(Z) = G ( 1/F(Z) ).
        </li>
        <li>
          <b>PRIME</b> returns any of the first PRIME_MAX prime numbers.
        </li>
        <li>
          <b>PYTHAG_TRIPLE_NEXT</b> computes the next Pythagorean triple.
        </li>
        <li>
          <b>R8_AGM</b> finds the arithmetic-geometric mean of two numbers.
        </li>
        <li>
          <b>R8_CHOOSE</b> computes the combinatorial coefficient C(N,K).
        </li>
        <li>
          <b>R8_FACTORIAL</b> computes the factorial of N.
        </li>
        <li>
          <b>R8_FALL</b> computes the falling factorial function [X]_N.
        </li>
        <li>
          <b>R8_FALL_VALUES</b> returns some values of the falling factorial function.
        </li>
        <li>
          <b>R8_GAMMA_LOG</b> calculates the natural logarithm of GAMMA ( X ) for positive X.
        </li>
        <li>
          <b>R8_IS_INT</b> determines if a real number represents an integer value.
        </li>
        <li>
          <b>R8_PI</b> returns the value of pi.
        </li>
        <li>
          <b>R8_RISE</b> computes the rising factorial function [X]^N.
        </li>
        <li>
          <b>R8_RISE_VALUES</b> returns some values of the rising factorial function.
        </li>
        <li>
          <b>R8_SWAP</b> switches two real values.
        </li>
        <li>
          <b>R8_TO_CFRAC</b> converts a real value to a continued fraction.
        </li>
        <li>
          <b>R8_TO_DEC</b> converts a real quantity to a decimal representation.
        </li>
        <li>
          <b>R8_TO_RAT</b> converts a real value to a rational value.
        </li>
        <li>
          <b>R8_TO_S_LEFT</b> represents a real using 14 left_justified characters.
        </li>
        <li>
          <b>R8_UNIFORM_01</b> returns a unit pseudorandom R8.
        </li>
        <li>
          <b>R8_UNIFORM_AB</b> returns a scaled pseudorandom R8.
        </li>
        <li>
          <b>R8MAT_DET</b> finds the determinant of an N by N R8MAT.
        </li>
        <li>
          <b>R8MAT_PERM</b> permutes the rows and columns of a square R8MAT.
        </li>
        <li>
          <b>R8MAT_PERM2</b> permutes rows and columns of a rectangular R8MAT, in place.
        </li>
        <li>
          <b>R8MAT_PERMANENT</b> computes the permanent of an R8MAT.
        </li>
        <li>
          <b>R8MAT_PRINT</b> prints an R8MAT.
        </li>
        <li>
          <b>R8MAT_PRINT_SOME</b> prints some of an R8MAT.
        </li>
        <li>
          <b>R8POLY</b> performs operations on real polynomials in power or factorial form.
        </li>
        <li>
          <b>R8POLY_ADD</b> adds two R8POLY's.
        </li>
        <li>
          <b>R8POLY_DEGREE</b> returns the degree of a polynomial in power sum form.
        </li>
        <li>
          <b>R8POLY_DIF</b> differentiates an R8POLY.
        </li>
        <li>
          <b>R8POLY_DIV</b> computes the quotient and remainder of two polynomials.
        </li>
        <li>
          <b>R8POLY_F2P</b> converts a real polynomial from factorial form to power sum form.
        </li>
        <li>
          <b>R8POLY_FVAL</b> evaluates a real polynomial in factorial form.
        </li>
        <li>
          <b>R8POLY_MUL</b> computes the product of two real polynomials A and B.
        </li>
        <li>
          <b>R8POLY_N2P</b> converts a real polynomial from Newton form to power sum form.
        </li>
        <li>
          <b>R8POLY_NVAL</b> evaluates a real polynomial in Newton form.
        </li>
        <li>
          <b>R8POLY_NX</b> replaces one of the base points in a polynomial in Newton form.
        </li>
        <li>
          <b>R8POLY_P2F</b> converts a real polynomial from power sum form to factorial form.
        </li>
        <li>
          <b>R8POLY_P2N</b> converts a real polynomial from power sum form to Newton form.
        </li>
        <li>
          <b>R8POLY_P2T</b> converts a real polynomial from power sum form to Taylor form.
        </li>
        <li>
          <b>R8POLY_POWER</b> computes a positive integer power of a polynomial.
        </li>
        <li>
          <b>R8POLY_PRINT</b> prints out a polynomial.
        </li>
        <li>
          <b>R8POLY_PVAL</b> evaluates a real polynomial in power sum form.
        </li>
        <li>
          <b>R8POLY_T2P</b> converts a real polynomial from Taylor form to power sum form.
        </li>
        <li>
          <b>R8VEC_BACKTRACK</b> supervises a backtrack search for an R8VEC.
        </li>
        <li>
          <b>R8VEC_FRAC</b> searches for the K-th smallest entry in an R8VEC.
        </li>
        <li>
          <b>R8VEC_INDICATOR</b> sets an R8VEC to the indicator vector.
        </li>
        <li>
          <b>R8VEC_MIRROR_NEXT</b> steps through all sign variations of an R8VEC.
        </li>
        <li>
          <b>R8VEC_PRINT</b> prints an R8VEC.
        </li>
        <li>
          <b>R8VEC_UNIFORM</b> returns a scaled pseudorandom R8VEC.
        </li>
        <li>
          <b>R8VEC_UNIFORM_01</b> returns a unit pseudorandom R8VEC.
        </li>
        <li>
          <b>RANDOM_INITIALIZE</b> initializes the FORTRAN 90 random number seed.
        </li>
        <li>
          <b>RAT_ADD</b> adds two rational values.
        </li>
        <li>
          <b>RAT_DIV</b> divides one rational value by another.
        </li>
        <li>
          <b>RAT_FAREY</b> computes the N-th row of the Farey fraction table.
        </li>
        <li>
          <b>RAT_FAREY2</b> computes the next row of the Farey fraction table.
        </li>
        <li>
          <b>RAT_MUL</b> multiplies two fractions.
        </li>
        <li>
          <b>RAT_NORMALIZE</b> normalizes a rational number.
        </li>
        <li>
          <b>RAT_SUM_FORMULA</b> computes the formulas for sums of powers of integers.
        </li>
        <li>
          <b>RAT_TO_CFRAC</b> converts a rational value to a continued fraction.
        </li>
        <li>
          <b>RAT_TO_DEC</b> converts a rational to a decimal representation.
        </li>
        <li>
          <b>RAT_TO_R8</b> converts rational values to real values.
        </li>
        <li>
          <b>RAT_TO_S_LEFT</b> returns a left-justified representation of A/B.
        </li>
        <li>
          <b>RAT_WIDTH</b> returns the "width" of a rational number.
        </li>
        <li>
          <b>RATMAT_DET</b> finds the determinant of an N by N matrix of rational entries.
        </li>
        <li>
          <b>RATMAT_PRINT</b> prints out rational vectors or matrices.
        </li>
        <li>
          <b>REGRO_NEXT</b> computes restricted growth functions one at a time.
        </li>
        <li>
          <b>RFRAC_TO_CFRAC</b> converts rational polynomial fractions to continued fractions.
        </li>
        <li>
          <b>RFRAC_TO_JFRAC</b> converts a rational polynomial fraction to a J fraction.
        </li>
        <li>
          <b>S_BLANK_DELETE</b> removes blanks from a string, left justifying the remainder.
        </li>
        <li>
          <b>S_BLANKS_DELETE</b> replaces consecutive blanks by one blank.
        </li>
        <li>
          <b>S_EQI</b> is a case insensitive comparison of two strings for equality.
        </li>
        <li>
          <b>SCHROEDER</b> generates the Schroeder numbers.
        </li>
        <li>
          <b>SORT_HEAP_EXTERNAL</b> externally sorts a list of items into ascending order.
        </li>
        <li>
          <b>SUBCOMP_NEXT</b> computes the next subcomposition of N into K parts.
        </li>
        <li>
          <b>SUBCOMPNZ_NEXT</b> computes the next subcomposition of N into K nonzero parts.
        </li>
        <li>
          <b>SUBCOMPNZ2_NEXT</b> computes the next subcomposition of N into K nonzero parts.
        </li>
        <li>
          <b>SUBSET_BY_SIZE_NEXT</b> returns all subsets of an N set, in order of size.
        </li>
        <li>
          <b>SUBSET_GRAY_NEXT</b> generates all subsets of a set of order N, one at a time.
        </li>
        <li>
          <b>SUBSET_GRAY_RANK</b> ranks a subset of an N set, using the Gray code ordering.
        </li>
        <li>
          <b>SUBSET_GRAY_UNRANK</b> produces a subset of an N set of the given Gray code rank.
        </li>
        <li>
          <b>SUBSET_LEX_NEXT</b> generates the subsets of a set of N elements, one at a time.
        </li>
        <li>
          <b>SUBSET_RANDOM</b> selects a random subset of an N-set.
        </li>
        <li>
          <b>SUBTRIANGLE_NEXT</b> computes the next subtriangle of a triangle.
        </li>
        <li>
          <b>THUE_BINARY_NEXT</b> returns the next element in a binary Thue sequence.
        </li>
        <li>
          <b>THUE_TERNARY_NEXT</b> returns the next element in a ternary Thue sequence.
        </li>
        <li>
          <b>TIMESTAMP</b> prints the current YMDHMS date as a time stamp.
        </li>
        <li>
          <b>TRIANG</b> renumbers elements in accordance with a partial ordering.
        </li>
        <li>
          <b>TUPLE_NEXT</b> computes the next element of a tuple space.
        </li>
        <li>
          <b>TUPLE_NEXT_FAST</b> computes the next element of a tuple space, "fast".
        </li>
        <li>
          <b>TUPLE_NEXT_GE</b> computes the next "nondecreasing" element of a tuple space.
        </li>
        <li>
          <b>TUPLE_NEXT2</b> computes the next element of an integer tuple space.
        </li>
        <li>
          <b>UBVEC_ADD</b> adds two unsigned binary vectors.
        </li>
        <li>
          <b>UBVEC_TO_UI4</b> makes an unsigned integer from an unsigned binary vector.
        </li>
        <li>
          <b>UBVEC_XOR</b> computes the exclusive OR of two unsigned binary vectors.
        </li>
        <li>
          <b>UI4_TO_UBVEC</b> makes an unsigned binary vector from an unsigned integer.
        </li>
        <li>
          <b>VEC_COLEX_NEXT</b> generates vectors in colex order.
        </li>
        <li>
          <b>VEC_COLEX_NEXT2</b> generates vectors in colex order.
        </li>
        <li>
          <b>VEC_COLEX_NEXT3</b> generates vectors in colex order.
        </li>
        <li>
          <b>VEC_GRAY_RANK</b> computes the rank of a product space element.
        </li>
        <li>
          <b>VEC_GRAY_UNRANK</b> computes the product space element of a given rank.
        </li>
        <li>
          <b>VEC_GRAY_NEXT</b> computes the elements of a product space.
        </li>
        <li>
          <b>VEC_LEX_NEXT</b> generates vectors in lex order.
        </li>
        <li>
          <b>VEC_RANDOM</b> selects a random N-vector of integers modulo a given base.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT2</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT3</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT4</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT5</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT6</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_CONSTRAINED_NEXT7</b> returns the "next" constrained vector.
        </li>
        <li>
          <b>VECTOR_NEXT</b> returns the "next" integer vector between two ranges.
        </li>
        <li>
          <b>YTB_ENUM</b> enumerates the Young tables of size N.
        </li>
        <li>
          <b>YTB_NEXT</b> computes the next Young table for a given shape.
        </li>
        <li>
          <b>YTB_PRINT</b> prints a Young table.
        </li>
        <li>
          <b>YTB_RANDOM</b> selects a random Young table of a given shape.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../f_src.html">
      the FORTRAN90 source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 29 December 2014.
    </i>

    <!-- John Burkardt -->

  </body>


<!-- Mirrored from people.sc.fsu.edu/~jburkardt/f_src/subset/subset.html by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 21 Nov 2017 21:20:25 GMT -->
</html>

